..  BSD LICENSE
    Copyright 2016 6WIND S.A.
    Copyright 2016 Mellanox.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.
    * Neither the name of 6WIND S.A. nor the names of its
    contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.. _Generic_flow_API:

通用流API (rte_flow)
===========================

综述
--------

该API提供了通用的硬件配置方法，使硬件能够根据用于定义的规则匹配特定出入口流量，
改变硬件工作方式和查询相关计数器。

该API中所有符号名都是以 *rte_flow* 为前缀，并且定义在 ``rte_flow.h`` 文件中。

- 可以匹配的对象有包数据(协议头，负载)和属性(比如，物理网口，虚拟设备功能ID)

- 操作有丢弃包，传递到指定队列，传递到虚拟/物理设备处理函数或者端口，
  执行隧道卸载(tunnel offloads)，增加标签等。

该API是用来替换旧过滤框架(其包含了旧框架所有功能和过滤类型)的，比旧过滤框架更高级一些。
该API为所有PMD提供了清楚且通用的使用接口。

旧应用中API更新方法，参考 `API 迁移`_。

流规则
---------

描述
~~~~~~~~~~~

流规则是规则属性的组合，规则属性包括匹配模式和动作列表。流规则构成了该API的基础。

一个流规则能包含多个不同的动作(如，计数，转发前封包和解包)，
不需要多个流规则来实现多个动作。
也不需要应用处理不同动作顺序的硬件实现细节。

流规则支持优先级，比如一个包匹配两个流规则，那么优先级高的规则会被优先处理。
但是，无法保证硬件支持多优先级。当支持时，可用的优先级往往比较少，
这就是为什么优先级可以有PMD在软件层面实现(比如可以通过重新排序规则来模拟)。

为了尽量保持硬件无关性，默认认为所有规则有相同的优先级，
也就是重叠规则(一个包匹配多个过滤器)的动作执行顺序未定义。

PMD可以拒绝在同一个优先级上创建重叠规则(比如，匹配模式已存在)。

因此在给定优先级上没有重叠规则时，其结果是可预见的。这样的规则在所有协议层都可以完美工作。

流规则也可以分组，流规则优先级被分配到他们所属的组上。因此，
给定组内的流规则要么在其他组的前面处理，要么在其他组后面处理。

在内部，一个规则多动作的支持可能是基于非默认硬件优先级实现的，
因此这两种特性可能不会同时对应用可用。

考虑到设备允许的模式/动作组合不能预先知道，会导致暴露大量无用的功能。
DPDK提供了从当设备配置状态中验证给定规则的方法。

这可以让应用在初始化时(启动数据路径前)检查它需要的规则类型是否支持。
该方法可以在任何时候使用，前提条件是规则所需的资源应该存在(比如，一个目标RX队列应先被配置好)

每一个定义好的规则都和由PMD管理的不透明句柄(opaque handle)相关联，应用应该维护它。
这些句柄可以用于查询和管理规则，比如获取计数器或其他数据，销毁规则。

为避免在PMD侧出现资源泄露，应用在释放相关资源(如，队列和端口)前必须明确销毁句柄。

以下章节包括:

- **属性** (由 ``struct rte_flow_attr`` 表示): 流规则的属性，比如方向(入口或出口)和优先级。

- **模式项** (由 ``struct rte_flow_item`` 表示): 匹配模式的一部分，匹配对象是特定包数据或者流量属性。
  它描述了模式本身的属性，比如反向匹配。

- **匹配模式**: 要查找的流量属性，任意项组合。

- **动作** (由 ``struct rte_flow_action`` 表示): 包匹配时要执行的操作。

属性
~~~~~~~~~~

属性: 组
^^^^^^^^^^^^^^^^

可以给流规则指定组号进行分组。组号越小优先级越高。组0拥有最高优先级。

虽然是可选的，但还是鼓励应用尽可能多的把类似的规则分为一组，
这样可以充分利用硬件能力(比如，最佳匹配)和解决(打破)限制(比如，一组只能有一个匹配模式)。

注意，无法保证对多组的支持。

属性: 优先级
^^^^^^^^^^^^^^^^^^^

优先级可以分配给流规则。在规则组中，优先级值越小优先级越高，0是最高的。

组8中优先级0的规则的优先级总是低于组0中优先级8的规则的。

组和优先级是任意的，并且取决于应用，它们不必是连续的，也不必从0开始。
但是，不同设备的组和优先级的最大数量可能受已存在的流规则影响。

如果一个包匹配多条规则，结果是未定义的。它可能被意处理，
比如复制，甚至引发不可恢复的错误。

注意，无法保证对多优先级的支持。

属性: 流量方向
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

流规则可以应用到出口/入口流量。

我们至少要为流规则指定一个方向。但不限于一个方向，同一个流规则可以应用到两个方向上。

不建议同时在两个方向上指定一个规则，但在一些案例中是合理的(比如，共享计数器)

模式项(Pattern item)
~~~~~~~~~~~~

模式项分为两类:

- 协议头和包数据的匹配 (ANY, RAW, ETH, VLAN, IPV4,
  IPV6, ICMP, UDP, TCP, SCTP, VXLAN, MPLS, GRE 等), 通常和一个结构体相关。

- 元数据和模式处理匹配 (END, VOID, INVERT, PF,
  VF, PORT 等), 通常没有结构体与之相关。

模式项详情结构体用于匹配指定的协议(或模式的属性)。文档中会描述每个模式项。

目前，一个模式项类型可以有三个相关结构体:

- ``spec``: 匹配值 (如，IPv4地址)。

- ``last``: ``spec`` 字段的范围上限。

- ``mask``: 位掩码应用于 ``spec`` 和 ``last`` ，目的是区分哪些值算在内或者哪些值排除在外。
  (比如，用于匹配IPv4前缀)。

使用限制和规范:

- 只设置 ``mask`` 或者 ``last`` ，不设置 ``spec`` 是错误的。

- ``last`` 等于0或者等于相关的  ``spec`` 会被忽略；因为这无法指定一个范围。
  不支持比 ``spec`` 小的非零值。

- 设置 ``spec`` 而不设置 ``mask`` ，PMD会使用该模式项默认的mask
  (常量 ``rte_flow_item_{name}_mask`` )。
  

- 当这些都不设置(假设模式项类型支持)时等价于空(零) ``mask`` 宽(未指定)匹配。

- ``mask`` 是一个简单的位掩码，在解析 ``spec`` 和 ``last`` 内容前应用。
  (如使用不当会产生不可预期的结果) 比如，对于IPv4地址，``spec`` 为 *10.1.2.3*，
  ``last`` 为 *10.3.4.5* , ``mask`` 为 *255.255.0.0* ，
  那么最终有效范围变成 *10.1.0.0* to *10.3.255.255*。

模式项匹配以太网头的例子:

.. _table_rte_flow_pattern_item_example:

.. table:: Ethernet 项

   +----------+----------+--------------------+
   | Field    | Subfield | Value              |
   +==========+==========+====================+
   | ``spec`` | ``src``  | ``00:01:02:03:04`` |
   |          +----------+--------------------+
   |          | ``dst``  | ``00:2a:66:00:01`` |
   |          +----------+--------------------+
   |          | ``type`` | ``0x22aa``         |
   +----------+----------+--------------------+
   | ``last`` | 未指定                        |
   +----------+----------+--------------------+
   | ``mask`` | ``src``  | ``00:ff:ff:ff:00`` |
   |          +----------+--------------------+
   |          | ``dst``  | ``00:00:00:00:ff`` |
   |          +----------+--------------------+
   |          | ``type`` | ``0x0000``         |
   +----------+----------+--------------------+

无掩码位代表可以是任意值(如下的 ``?``)，因此，像下面的以太网头可以匹配到:

- ``src``: ``??:01:02:03:??``
- ``dst``: ``??:??:??:??:01``
- ``type``: ``0x????``

匹配模式
~~~~~~~~~~~~~~~~

匹配模式中与协议相关的模式项是从最底层协议开始匹配的(组成一个模式项栈)。该限制不会应用到元模式项，
元模式项可以放在模式中任何位置，并且不会影响到最终的匹配模式。

匹配模式由END项终结。

例子:

.. _table_rte_flow_tcpv4_as_l4:

.. table:: TCPv4 as L4

   +-------+----------+
   | Index | Item     |
   +=======+==========+
   | 0     | Ethernet |
   +-------+----------+
   | 1     | IPv4     |
   +-------+----------+
   | 2     | TCP      |
   +-------+----------+
   | 3     | END      |
   +-------+----------+

|

.. _table_rte_flow_tcpv6_in_vxlan:

.. table:: TCPv6 in VXLAN

   +-------+------------+
   | Index | Item       |
   +=======+============+
   | 0     | Ethernet   |
   +-------+------------+
   | 1     | IPv4       |
   +-------+------------+
   | 2     | UDP        |
   +-------+------------+
   | 3     | VXLAN      |
   +-------+------------+
   | 4     | Ethernet   |
   +-------+------------+
   | 5     | IPv6       |
   +-------+------------+
   | 6     | TCP        |
   +-------+------------+
   | 7     | END        |
   +-------+------------+

|

.. _table_rte_flow_tcpv4_as_l4_meta:

.. table:: TCPv4 as L4 with meta items

   +-------+----------+
   | Index | Item     |
   +=======+==========+
   | 0     | VOID     |
   +-------+----------+
   | 1     | Ethernet |
   +-------+----------+
   | 2     | VOID     |
   +-------+----------+
   | 3     | IPv4     |
   +-------+----------+
   | 4     | TCP      |
   +-------+----------+
   | 5     | VOID     |
   +-------+----------+
   | 6     | VOID     |
   +-------+----------+
   | 7     | END      |
   +-------+----------+

上面的例子说明了只要保持包数据模式项的正确的叠放顺序，
那么元模式项是不会影响包数据模式项的。所以上面的例子中匹配模式和"TCPv4 as L4"一样。

.. _table_rte_flow_udpv6_anywhere:

.. table:: UDPv6 anywhere

   +-------+------+
   | Index | Item |
   +=======+======+
   | 0     | IPv6 |
   +-------+------+
   | 1     | UDP  |
   +-------+------+
   | 2     | END  |
   +-------+------+

如果PMD支持，省略栈底的一个或几个协议层(如上例未指定以太网层)，
则会查找包中任意位置。

这种情况下未指定封装负载(比如，VXLAN负载)要匹配哪种包，可能是封装的内部包，外部包或者两者都是。

.. _table_rte_flow_invalid_l3:

.. table:: 无效, 缺少L3协议

   +-------+----------+
   | Index | Item     |
   +=======+==========+
   | 0     | Ethernet |
   +-------+----------+
   | 1     | UDP      |
   +-------+----------+
   | 2     | END      |
   +-------+----------+

上面的匹配模式中因为在L2(Ethernet)和L4(UDP)之间未指定L3协议，所以是无效的。
层级的缺失只能发生在栈顶或栈底。

元模式项类型
~~~~~~~~~~~~~~~

元模式项匹配的是元数据，或者影响模式处理而不是直接匹配包数据，大多数的元模式项不需要指定数据结构。
这个例外可以让元模式项处在栈中任何位置并不会产生副作用。

元模式项: ``END``
^^^^^^^^^^^^^

模式项列表的结束标志。防止超范围的模式项处理，从而结束模式匹配。

- 为了方便起见，它的数值为0。
- PMD必须支持。
- 忽略 ``spec``, ``last`` 和 ``mask``。

.. _table_rte_flow_item_end:

.. table:: END

   +----------+---------+
   | Field    | Value   |
   +==========+=========+
   | ``spec`` | ignored |
   +----------+---------+
   | ``last`` | ignored |
   +----------+---------+
   | ``mask`` | ignored |
   +----------+---------+

元模式项: ``VOID``
^^^^^^^^^^^^^^

该元模式项是个占位符。PMD在处理时会忽略并丢弃该元模式项。

- PMD必须支持。
- 忽略 ``spec``, ``last`` 和 ``mask``。

.. _table_rte_flow_item_void:

.. table:: VOID

   +----------+---------+
   | Field    | Value   |
   +==========+=========+
   | ``spec`` | ignored |
   +----------+---------+
   | ``last`` | ignored |
   +----------+---------+
   | ``mask`` | ignored |
   +----------+---------+

该类型的一个使用案例是流规则快速共享通用前缀，不用重新申请内存，仅更新模式项类型:

.. _table_rte_flow_item_void_example:

.. table:: TCP, UDP or ICMP as L4

   +-------+--------------------+
   | Index | Item               |
   +=======+====================+
   | 0     | Ethernet           |
   +-------+--------------------+
   | 1     | IPv4               |
   +-------+------+------+------+
   | 2     | UDP  | VOID | VOID |
   +-------+------+------+------+
   | 3     | VOID | TCP  | VOID |
   +-------+------+------+------+
   | 4     | VOID | VOID | ICMP |
   +-------+------+------+------+
   | 5     | END                |
   +-------+--------------------+

元模式项: ``INVERT``
^^^^^^^^^^^^^^^^

反向匹配, 也就是处理与该模式不匹配的包。

- 忽略 ``spec``, ``last`` and ``mask``。

.. _table_rte_flow_item_invert:

.. table:: INVERT

   +----------+---------+
   | Field    | Value   |
   +==========+=========+
   | ``spec`` | ignored |
   +----------+---------+
   | ``last`` | ignored |
   +----------+---------+
   | ``mask`` | ignored |
   +----------+---------+

使用案例，仅匹配非TCPv4包:

.. _table_rte_flow_item_invert_example:

.. table:: Anything but TCPv4

   +-------+----------+
   | Index | Item     |
   +=======+==========+
   | 0     | INVERT   |
   +-------+----------+
   | 1     | Ethernet |
   +-------+----------+
   | 2     | IPv4     |
   +-------+----------+
   | 3     | TCP      |
   +-------+----------+
   | 4     | END      |
   +-------+----------+

元模式项: ``PF``
^^^^^^^^^^^^

匹配发送到设备物理功能的包。

如果底层设备功能无法正常接收匹配流量，则使用该元模式项可以防止流量到达该设备，
除非流规则包含 `动作: PF`_。默认数据包不会在设备实例间复制。

- 该元模式项如果应用到VF设备很可能会返回错误或者根本不会匹配到任何流量。

- 可以和任何数量的  `元模式项: VF`_ 组合匹配PF和VF流量。
  
- ``spec``, ``last`` 和 ``mask`` 不允许设置。

.. _table_rte_flow_item_pf:

.. table:: PF

   +----------+-------+
   | Field    | Value |
   +==========+=======+
   | ``spec`` | unset |
   +----------+-------+
   | ``last`` | unset |
   +----------+-------+
   | ``mask`` | unset |
   +----------+-------+

元模式项: ``VF``
^^^^^^^^^^^^

匹配发送到设备虚拟功能的包。

如果底层设备功能无法正常接收匹配流量，则使用该元模式项可以防止流量到达该设备，
除非流规则包含 `动作: VF`_ 。默认数据包不会在设备实例间复制。

- 该元模式项如果应用到VF设备很可能会返回错误或者根本不会匹配到任何流量。

- 可以和任何数量的  `元模式项: VF`_ 组合匹配PF和VF流量。
  
- ``spec``, ``last`` 和 ``mask`` 不允许设置。

- 如果让VF设备去匹配发送到不同VF上的流量时，很可能会返回错误或者根本不会匹配到任何流量。
  
- 可以通过多次指定该元模式项去匹配发送到多个VF上的流量。
  
- 可以和PF模式项组合匹配FP和VF流量。

- 默认 ``mask`` 匹配任何VF。

.. _table_rte_flow_item_vf:

.. table:: VF

   +----------+----------+---------------------------+
   | Field    | Subfield | Value                     |
   +==========+==========+===========================+
   | ``spec`` | ``id``   | destination VF ID         |
   +----------+----------+---------------------------+
   | ``last`` | ``id``   | 上限                      |
   +----------+----------+---------------------------+
   | ``mask`` | ``id``   | 0值匹配任何VF ID          |
   +----------+----------+---------------------------+

元模式项: ``PORT``
^^^^^^^^^^^^^^

匹配来自底层设备物理端口的数据包。

第一个PORT模式项覆盖了和DPDK相关联(port_id)的物理端口。
可以提供多个该模式项匹配多个物理端口。

注意，当物理端口不在DPDK控制下时，就不必绑定到DPDK输入端口(port_id)上。
每个设备会有一个port_id，他们不必从0开始，也可能不是连续的。

作为设备的属性，合法的端口号应该通过其他方法获得。

- 默认 ``mask`` 匹配任何端口号。

.. _table_rte_flow_item_port:

.. table:: PORT

   +----------+-----------+--------------------------------+
   | Field    | Subfield  | Value                          |
   +==========+===========+================================+
   | ``spec`` | ``index`` | 物理端口号                     |
   +----------+-----------+--------------------------------+
   | ``last`` | ``index`` | 上限                           |
   +----------+-----------+--------------------------------+
   | ``mask`` | ``index`` | 0值匹配任何端口号              |
   +----------+-----------+--------------------------------+

数据匹配项类型
~~~~~~~~~~~~~~~~~~~~~~~~

这些类型基本上都是协议头和相关位掩码的定义。这些类型必须按照从最低到最高协议层排列成一个栈，
组成一个匹配模式。

下面的列表并不是全面的，未来可能会有新协议加入进来。

数据模式项: ``ANY``
^^^^^^^^^^^^^

匹配任何协议，而不是仅匹配当前协议层，一个单个的ANY也可以代表多个协议层。

当在包中任意层查找一个协议时，``ANY`` 通常作为第一个模式项。

- 默认 ``mask`` 代表任意层数。

.. _table_rte_flow_item_any:

.. table:: ANY

   +----------+----------+--------------------------------------+
   | Field    | Subfield | Value                                |
   +==========+==========+======================================+
   | ``spec`` | ``num``  | 覆盖的层数                           |
   +----------+----------+--------------------------------------+
   | ``last`` | ``num``  | 上限                                 |
   +----------+----------+--------------------------------------+
   | ``mask`` | ``num``  | 0代表任意层数                        |
   +----------+----------+--------------------------------------+

VXLAN TCP负载匹配的例子，外部的L3(IPv4 or IPv6)和L4(UDP)都是由第一个 ANY 匹配。
内部的L3 (IPv4 or IPv6)由第二个 ANY 匹配:

.. _table_rte_flow_item_any_example:

.. table:: 使用 ANY 通配符匹配VXLAN中的TCP

   +-------+------+----------+----------+-------+
   | Index | Item | Field    | Subfield | Value |
   +=======+======+==========+==========+=======+
   | 0     | Ethernet                           |
   +-------+------+----------+----------+-------+
   | 1     | ANY  | ``spec`` | ``num``  | 2     |
   +-------+------+----------+----------+-------+
   | 2     | VXLAN                              |
   +-------+------------------------------------+
   | 3     | Ethernet                           |
   +-------+------+----------+----------+-------+
   | 4     | ANY  | ``spec`` | ``num``  | 1     |
   +-------+------+----------+----------+-------+
   | 5     | TCP                                |
   +-------+------------------------------------+
   | 6     | END                                |
   +-------+------------------------------------+

数据模式项: ``RAW``
^^^^^^^^^^^^^


在给定的偏移位置上匹配给定长度的字符串。

偏移位置可以是绝对位置(从包的起始位置开始)或者是相对位置(相对于匹配项栈中前一个匹配项结束位置)，
相对位置可以是负数。

如果开启搜索功能，偏移位置用作起始点。搜索区域可以通过一个非零值(该值就是偏移位置后的最大字节数)进行限定。

可以设置匹配0长度字符串，这样做可以重置随后匹配项的相对偏移位置。

- 该类型不支持范围 (``last`` 字段).
- 默认 ``mask`` 严格匹配所有字段。

.. _table_rte_flow_item_raw:

.. table:: RAW

   +----------+--------------+-------------------------------------------------+
   | Field    | Subfield     | Value                                           |
   +==========+==============+=================================================+
   | ``spec`` | ``relative`` | 前一个匹配的搜索模式                            |
   |          +--------------+-------------------------------------------------+
   |          | ``search``   | 搜索模式                                        |
   |          +--------------+-------------------------------------------------+
   |          | ``reserved`` | 预留，必须设置为0                               |
   |          +--------------+-------------------------------------------------+
   |          | ``offset``   | 绝对偏移或相对偏移                              |
   |          +--------------+-------------------------------------------------+
   |          | ``limit``    | 搜索区域限制                                    |
   |          +--------------+-------------------------------------------------+
   |          | ``length``   | 字符串长度                                      |
   |          +--------------+-------------------------------------------------+
   |          | ``pattern``  | 要查找的字符串                                  |
   +----------+--------------+-------------------------------------------------+
   | ``last`` | 全0或者与 ``spec`` 一样                                        |
   +----------+----------------------------------------------------------------+
   | ``mask`` | 应用于 ``spec`` 值                                              |
   +----------+----------------------------------------------------------------+

示例，使用RAW匹配项在UDP负载多个偏移位置上查找字符串:
.. _table_rte_flow_item_raw_example:

.. table:: UDP 负载匹配

   +-------+------+----------+--------------+-------+
   | Index | Item | Field    | Subfield     | Value |
   +=======+======+==========+==============+=======+
   | 0     | Ethernet                               |
   +-------+----------------------------------------+
   | 1     | IPv4                                   |
   +-------+----------------------------------------+
   | 2     | UDP                                    |
   +-------+------+----------+--------------+-------+
   | 3     | RAW  | ``spec`` | ``relative`` | 1     |
   |       |      |          +--------------+-------+
   |       |      |          | ``search``   | 1     |
   |       |      |          +--------------+-------+
   |       |      |          | ``offset``   | 10    |
   |       |      |          +--------------+-------+
   |       |      |          | ``limit``    | 0     |
   |       |      |          +--------------+-------+
   |       |      |          | ``length``   | 3     |
   |       |      |          +--------------+-------+
   |       |      |          | ``pattern``  | "foo" |
   +-------+------+----------+--------------+-------+
   | 4     | RAW  | ``spec`` | ``relative`` | 1     |
   |       |      |          +--------------+-------+
   |       |      |          | ``search``   | 0     |
   |       |      |          +--------------+-------+
   |       |      |          | ``offset``   | 20    |
   |       |      |          +--------------+-------+
   |       |      |          | ``limit``    | 0     |
   |       |      |          +--------------+-------+
   |       |      |          | ``length``   | 3     |
   |       |      |          +--------------+-------+
   |       |      |          | ``pattern``  | "bar" |
   +-------+------+----------+--------------+-------+
   | 5     | RAW  | ``spec`` | ``relative`` | 1     |
   |       |      |          +--------------+-------+
   |       |      |          | ``search``   | 0     |
   |       |      |          +--------------+-------+
   |       |      |          | ``offset``   | -29   |
   |       |      |          +--------------+-------+
   |       |      |          | ``limit``    | 0     |
   |       |      |          +--------------+-------+
   |       |      |          | ``length``   | 3     |
   |       |      |          +--------------+-------+
   |       |      |          | ``pattern``  | "baz" |
   +-------+------+----------+--------------+-------+
   | 6     | END                                    |
   +-------+----------------------------------------+

解释:

- 在UDP负载第10个字符处开始查找"foo"
- 在"foo"后第20字节处开始查找"bar"
- 在"bar"前第29字节处开始查找"baz"

包示例 (非等比例)::

 0                     >= 10 B           == 20 B
 |                  |<--------->|     |<--------->|
 |                  |           |     |           |
 |-----|------|-----|-----|-----|-----|-----------|-----|------|
 | ETH | IPv4 | UDP | ... | baz | foo | ......... | bar | .... |
 |-----|------|-----|-----|-----|-----|-----------|-----|------|
                          |                             |
                          |<--------------------------->|
                                      == 29 B

注意，后续的模式项将从"baz"开始，而不是"bar"，因为匹配总是接着上一个匹配项开始执行的。

数据模式项: ``ETH``
^^^^^^^^^^^^^

匹配以太网头

- ``dst``: 目的 MAC.
- ``src``: 源 MAC.
- ``type``: 类型
- 默认 ``mask`` 仅匹配目的地址和源地址

数据模式项: ``VLAN``
^^^^^^^^^^^^^^

匹配 802.1Q/ad VLAN 标签

- ``tpid``: 标签协议标识符
- ``tci``: 标签控制信息
- 默认 ``mask`` 仅匹配TCI

数据模式项: ``IPV4``
^^^^^^^^^^^^^^

匹配IPv4头

注意: IPv4 选项是由专门的模式项来处理的。

- ``hdr``: IPv4 头定义 (``rte_ip.h``).
- 默认 ``mask`` 仅匹配目的地址和源地址

数据模式项: ``IPV6``
^^^^^^^^^^^^^^

匹配IPv6头

注意: IPv6 选项是由专门的模式项来处理的。

- ``hdr``: IPv6 头定义 (``rte_ip.h``).
- 默认 ``mask`` 仅匹配目的地址和源地址

数据模式项: ``ICMP``
^^^^^^^^^^^^^^

匹配 ICMP 头

- ``hdr``: ICMP 头定义 (``rte_icmp.h``).
- 默认 ``mask`` 仅匹配ICMP类型和代码

数据模式项: ``UDP``
^^^^^^^^^^^^^

匹配UDP头

- ``hdr``: UDP 头定义 (``rte_udp.h``).
- 默认 ``mask`` 仅匹配源端口和目的端口

数据模式项: ``TCP``
^^^^^^^^^^^^^

匹配TCP头

- ``hdr``: TCP 头定义 (``rte_tcp.h``).
- 默认 ``mask`` 仅匹配源端口和目的端口

数据模式项: ``SCTP``
^^^^^^^^^^^^^^

匹配SCTP头

- ``hdr``: SCTP 头定义 (``rte_sctp.h``).
- 默认 ``mask`` 仅匹配源端口和目的端口

数据模式项: ``VXLAN``
^^^^^^^^^^^^^^^

匹配VXLAN头(RFC 7348).

- ``flags``: 通常是 0x08 (I flag).
- ``rsvd0``: 预留, 通常是 0x000000.
- ``vni``: VXLAN网络标识符
- ``rsvd1``: 预留, 通常是 0x00.
- 默认 ``mask`` 仅匹配VNI

数据模式项: ``E_TAG``
^^^^^^^^^^^^^^^

匹配 IEEE 802.1BR E-Tag 头

- ``tpid``: 标签协议标识符(0x893F)
- ``epcp_edei_in_ecid_b``: E-Tag 控制信息 (E-TCI), E-PCP (3b),
  E-DEI (1b), ingress E-CID base (12b).
- ``rsvd_grp_ecid_b``: reserved (2b), GRP (2b), E-CID base (12b).
- ``in_ecid_e``: ingress E-CID ext.
- ``ecid_e``: E-CID ext.
- 默认 ``mask`` 同时匹配GRP 和 E-CID base.

数据模式项: ``NVGRE``
^^^^^^^^^^^^^^^

匹配NVGRE头 (RFC 7637).

- ``c_k_s_rsvd0_ver``: checksum (1b), undefined (1b), key bit (1b),
  sequence number (1b), reserved 0 (9b), version (3b). This field must have
  value 0x2000 according to RFC 7637.
- ``protocol``: 协议类型 (0x6558).
- ``tni``: 虚拟子网ID.
- ``flow_id``: 流ID.
- 默认 ``mask`` 仅匹配TNI。

数据模式项: ``MPLS``
^^^^^^^^^^^^^^

匹配MPLS头

- ``label_tc_s_ttl``: label, TC, Bottom of Stack and TTL.
- 默认 ``mask`` 仅匹配label。

数据模式项: ``GRE``
^^^^^^^^^^^^^^

匹配GRE头

- ``c_rsvd0_ver``: checksum, reserved 0 and version.
- ``protocol``: 协议类型
- 默认 ``mask`` 仅匹配协议

动作
~~~~~~~

每种动作都由一个类型表示。有的动作有配置结构。合并在一个列表中的多个动作能够受到一个流规则的影响。
该列表是无序的。

动作有三类:

- 终止动作 (比如 QUEUE, DROP, RSS, PF, VF)终止后续流规则处理匹配包，除非用 PASSTHRU 覆盖。

- 非终止动作(PASSTHRU, DUP)把匹配的包留给后续流规则处理。

- 其他非终止类元动作，这类动作不会影响到包的处理(END, VOID, MARK, FLAG, COUNT)。

当多个动作合并到一个流规则中时，它们应该是不同类型的(比如，同一个包不能丢弃两次)。

对于给定的动作类型只有最后一个动作有效。但PMD仍会对整个表执行错误检查。

和匹配模式类似，动作列表也是有 END 项结束的。

*注意PASSTHRU是唯一能够覆盖终止规则的动作。*

实例，把包重定向到10号队列:

.. _table_rte_flow_action_example:

.. table:: 队列动作

   +-----------+-------+
   | Field     | Value |
   +===========+=======+
   | ``index`` | 10    |
   +-----------+-------+

动作列表示例，顺序是没有意义的，应用必须考虑到所有动作可以同时执行。

.. _table_rte_flow_count_and_drop:

.. table:: 统计和丢弃

   +-------+--------+
   | Index | Action |
   +=======+========+
   | 0     | COUNT  |
   +-------+--------+
   | 1     | DROP   |
   +-------+--------+
   | 2     | END    |
   +-------+--------+

|

.. _table_rte_flow_mark_count_redirect:

.. table:: 标记，统计和重定向

   +-------+--------+-----------+-------+
   | Index | Action | Field     | Value |
   +=======+========+===========+=======+
   | 0     | MARK   | ``mark``  | 0x2a  |
   +-------+--------+-----------+-------+
   | 1     | COUNT                      |
   +-------+--------+-----------+-------+
   | 2     | QUEUE  | ``queue`` | 10    |
   +-------+--------+-----------+-------+
   | 3     | END                        |
   +-------+----------------------------+

|

.. _table_rte_flow_redirect_queue_5:

.. table:: 重定向到5号队列

   +-------+--------+-----------+-------+
   | Index | Action | Field     | Value |
   +=======+========+===========+=======+
   | 0     | DROP                       |
   +-------+--------+-----------+-------+
   | 1     | QUEUE  | ``queue`` | 5     |
   +-------+--------+-----------+-------+
   | 2     | END                        |
   +-------+----------------------------+

在上面的例子中，考虑到两者同时执行，最终结果仅有QUEUE有效。

.. _table_rte_flow_redirect_queue_3:

.. table:: 重定向到3号队列

   +-------+--------+-----------+-------+
   | Index | Action | Field     | Value |
   +=======+========+===========+=======+
   | 0     | QUEUE  | ``queue`` | 5     |
   +-------+--------+-----------+-------+
   | 1     | VOID                       |
   +-------+--------+-----------+-------+
   | 2     | QUEUE  | ``queue`` | 3     |
   +-------+--------+-----------+-------+
   | 3     | END                        |
   +-------+----------------------------+

如前面的描述，列表中对于给定类型(本例中QUEUE)仅有最后一个动作有效。上例中也展示了VOID只是被简单忽略。

动作类型
~~~~~~~~~~~~

本节描述了通用动作类型。本节内容并不是全面的，未来可能会有新动作加入进来。

动作: ``END``
^^^^^^^^^^^^^^^

动作列表的结束标记。阻止超范围的动作处理，进而结束列表。

- 为了方便起见，它的数值为0。
- PMD必须支持。
- 无配置属性。

.. _table_rte_flow_action_end:

.. table:: END

   +---------------+
   | Field         |
   +===============+
   | 无属性        |
   +---------------+

动作: ``VOID``
^^^^^^^^^^^^^^^^

作为占位符使用。PMD忽略并简单丢弃它。

- PMD必须支持。
- 无配置属性。

.. _table_rte_flow_action_void:

.. table:: VOID

   +---------------+
   | Field         |
   +===============+
   | 无属性        |
   +---------------+

动作: ``PASSTHRU``
^^^^^^^^^^^^^^^^^^^^

把包留给后续流规则处理。当规则中不包含终止动作时，该动作是默认动作。
也可以给规则指定该动作使之变成非终止的。

- 无配置属性。

.. _table_rte_flow_action_passthru:

.. table:: PASSTHRU

   +---------------+
   | Field         |
   +===============+
   | 无属性        |
   +---------------+

实例，把包拷贝一份给队列，然后由后续流规则继续处理该包:

.. _table_rte_flow_action_passthru_example:

.. table:: 拷贝到8号队列

   +-------+--------+-----------+-------+
   | Index | Action | Field     | Value |
   +=======+========+===========+=======+
   | 0     | PASSTHRU                   |
   +-------+--------+-----------+-------+
   | 1     | QUEUE  | ``queue`` | 8     |
   +-------+--------+-----------+-------+
   | 2     | END                        |
   +-------+----------------------------+

动作: ``MARK``
^^^^^^^^^^^^^^^^

给包绑定一个整数值并设置 ``PKT_RX_FDIR`` 和 ``PKT_RX_FDIR_ID`` mbuf 标志。

该值由应用任意指定。最大值依赖底层实现。该值由 ``hash.fdir.hi`` mbuf 字段返回。

.. _table_rte_flow_action_mark:

.. table:: MARK

   +--------+--------------------------------------+
   | Field  | Value                                |
   +========+======================================+
   | ``id`` | integer value to return with packets |
   +--------+--------------------------------------+

动作: ``FLAG``
^^^^^^^^^^^^^^^^

标记包。和 `动作: MARK`_ 相似，但不会指定值；仅设置 ``PKT_RX_FDIR`` mbuf 标志。

- 无配置属性。

.. _table_rte_flow_action_flag:

.. table:: FLAG

   +---------------+
   | Field         |
   +===============+
   | 无属性        |
   +---------------+

动作: ``QUEUE``
^^^^^^^^^^^^^^^^^

把包分派到给定队列。

- Terminating by default.

.. _table_rte_flow_action_queue:

.. table:: QUEUE

   +-----------+--------------------+
   | Field     | Value              |
   +===========+====================+
   | ``index`` | 队列索引           |
   +-----------+--------------------+

动作: ``DROP``
^^^^^^^^^^^^^^^^

丢弃包。

- 无配置属性。
- 默认为终止动作。
- 如果和 PASSTHRU 同时指定的话，该动作会被 PASSTHRU 覆盖。

.. _table_rte_flow_action_drop:

.. table:: DROP

   +---------------+
   | Field         |
   +===============+
   | 无属性        |
   +---------------+

动作: ``COUNT``
^^^^^^^^^^^^^^^^^

开启规则的计数器。

这些计数器可以通过 ``rte_flow_query()`` 获取和重置，参考 ``struct rte_flow_query_count`` 。

- 计数器可以通过 ``rte_flow_query()`` 获取。
- 无配置属性。

.. _table_rte_flow_action_count:

.. table:: COUNT

   +---------------+
   | Field         |
   +===============+
   | 无属性        |
   +---------------+

查询和重置流规则计数器的查询结构体( ``struct rte_flow_query_count`` ):

.. _table_rte_flow_query_count:

.. table:: COUNT query

   +---------------+-----+-----------------------------------+
   | Field         | I/O | Value                             |
   +===============+=====+===================================+
   | ``reset``     | in  | 查询后重置计数器                  |
   +---------------+-----+-----------------------------------+
   | ``hits_set``  | out | 设置 ``hits`` 字段                |
   +---------------+-----+-----------------------------------+
   | ``bytes_set`` | out | 设置 ``bytes`` 字段               |
   +---------------+-----+-----------------------------------+
   | ``hits``      | out | 该规则被击中次数                  |
   +---------------+-----+-----------------------------------+
   | ``bytes``     | out | 通过该规则的字节数                |
   +---------------+-----+-----------------------------------+

动作: ``DUP``
^^^^^^^^^^^^^^^

复制包到指定队列。

正常要和QUEUE组合使用，而单独使用时它其实和 QUEUE + PASSTHRU 类似。

- 默认为非终止动作。

.. _table_rte_flow_action_dup:

.. table:: DUP

   +-----------+------------------------------------+
   | Field     | Value                              |
   +===========+====================================+
   | ``index`` | 队列索引                           |
   +-----------+------------------------------------+

动作: ``RSS``
^^^^^^^^^^^^^^^

和QUEUE类似，除了RSS根据参数把包分散传输到多个队列中。

注意：RSS哈希结果保存在mbuf的 ``hash.rss`` 字段，该字段与 ``hash.fdir.lo`` 重叠。
因为 `动作: MARK`_ 仅设置了 ``hash.fdir.hi`` 字段，所以这两个字段可以同时被获取。

- 默认为终止动作。

.. _table_rte_flow_action_rss:

.. table:: RSS

   +--------------+------------------------------+
   | Field        | Value                        |
   +==============+==============================+
   | ``rss_conf`` | RSS 参数                     |
   +--------------+------------------------------+
   | ``num``      | queue[] 中实体个数           |
   +--------------+------------------------------+
   | ``queue[]``  | 队列索引列表                 |
   +--------------+------------------------------+

动作: ``PF``
^^^^^^^^^^^^^^

将数据包重定向到当前设备的物理功能(PF)。

- 无配置属性。
- 默认为终止动作。

.. _table_rte_flow_action_pf:

.. table:: PF

   +---------------+
   | Field         |
   +===============+
   | 无属性        |
   +---------------+

动作: ``VF``
^^^^^^^^^^^^^^

将数据包重定向到当前设备的虚拟功能(VF)。

VF模式项匹配的包可以重定向到包的原始VF上，而不是指定的VF。
如果VF部分和之前的流规则匹配或者包最开始时不是发送到一个VF上时，
该参数可能不可用并且不保证其可以正常工作。

- 默认为终止动作。

.. _table_rte_flow_action_vf:

.. table:: VF

   +--------------+--------------------------------+
   | Field        | Value                          |
   +==============+================================+
   | ``original`` | 原始的VF ID                    |
   +--------------+--------------------------------+
   | ``vf``       | VF ID                          |
   +--------------+--------------------------------+

负数类型
~~~~~~~~~~~~~~

所有指定的模式项 (``enum rte_flow_item_type``) 和动作
(``enum rte_flow_action_type``) 都使用正数标识符。

负数预留给PMD运行时产生的动态类型。PMD可能会遇到负数的结果，但不能接收PMD无法识别的负数。

生成负数的方法待定义。

计划中的类型
~~~~~~~~~~~~~

当有新的协议出现时，模式项类型就会增加。

各种协议头是通过专门的模式项支持的，比如为了匹配IPv4选项和IPv6扩展头，
相关的模式项就要放在IPv4/IPv6后面(栈中)。

其他的动作类型在规划中，但还未定义。其中包括通过多种方式修改包数据，如隧道头的封装/解封。

规则管理
----------------

非常简单的用于全面管理流规则的API。

每个创建好的流规则都和一个不透明的，PMD特定的句柄(指针)相关联。
应用应该在规则销毁前一直保存该指针。

流规则由 ``struct rte_flow`` 表示。

校验
~~~~~~~~~~

考虑到暴露大量设备能力是不切实际的，所以提供了一个专门的函数用于检查某个流规则是否支持。

.. code-block:: c

   int
   rte_flow_validate(uint8_t port_id,
                     const struct rte_flow_attr *attr,
                     const struct rte_flow_item pattern[],
                     const struct rte_flow_action actions[],
                     struct rte_flow_error *error);

该函数验证流规则的正确性和设备是否能接收该流规则。对照当前设备模式和队列配置检查流规则。
流规则也可以对照已存在的流规则和设备资源进行验证。该函数对目标设备没有影响。

由于可能的冲突或者资源限制(although in such cases ``EINVAL`` should not be returned)，
只要在同一时间没有成功调用过 ``rte_flow_create()`` 或 ``rte_flow_destroy()``
和修改过应用到流规则上的设备参数就可以保证函数返回值合法。

参数:

- ``port_id``: 以太网设备端口标识符。
- ``attr``: 流规则属性。
- ``pattern``: 模式说明 (以END项终止的列表)。
- ``actions``: 相关的动作(以END动作终止的列表)。
- ``error``: 发生错误时PMD会初始化该结构体用于报告详细的错误信息。

返回值:

- 流规则合法且可以创建返回0。否则返回负数(``rte_errno`` 也会被设置)， 下面定义了一些错误值。
- ``-ENOSYS``: 底层设备不支持该功能。
- ``-EINVAL``: 流规则未知或非法。
- ``-ENOTSUP``: 流规则有效但设备不支持(比如，部分位掩码不支持)。
- ``EEXIST``: 与已存在的流规则冲突。仅在设备支持流规则冲突检测并且确实检测到冲突时才返回该值。
  没有返回该值并不保证流规不会因为冲突创建失败。
- ``ENOMEM``: 内存不足，或者设备支持资源验证，资源限制。
- ``-EBUSY``: 设备忙碌操作无法执行， 可能在受影响队列或整个端口处于停止状态(参考 ``rte_eth_dev_rx_queue_stop()`` 和 ``rte_eth_dev_stop()``)时会成功。

创建
~~~~~~~~

创建流规则和验证流规则类似，除了会确实创建流规则并返回流规则句柄。

.. code-block:: c

   struct rte_flow *
   rte_flow_create(uint8_t port_id,
                   const struct rte_flow_attr *attr,
                   const struct rte_flow_item pattern[],
                   const struct rte_flow_action *actions[],
                   struct rte_flow_error *error);

参数:

- ``port_id``: 以太网设备端口标识符。
- ``attr``: 流规则属性。
- ``pattern``: 模式说明 (以END项终止的列表)。
- ``actions``: 相关的动作(以END动作终止的列表)。
- ``error``: 发生错误时PMD会初始化该结构体用于报告详细的错误信息。

返回值:

成功返回一个合法的句柄，否则返回NULL并且 ``rte_errno`` 被设置为错误码(为 ``rte_flow_validate()`` 定义的)的正数版本。

销毁
~~~~~~~~~~~

流规则的销毁不是原子操作，在流规则仍绑定在资源(队列或端口)上时，这些资源不应该释放。
应用必须在释放资源前执行销毁步骤。

.. code-block:: c

   int
   rte_flow_destroy(uint8_t port_id,
                    struct rte_flow *flow,
                    struct rte_flow_error *error);


当一个流规则被其他流规则依赖时，销毁该流规则可能会失败，并且销毁它会导致状态不一致问题。

该函数仅保证逆序(创建顺序)销毁流规则才会成功。

参数:

- ``port_id``: 以太网设备端口标识符。
- ``flow``: 要销毁的流规则句柄。
- ``error``: 发生错误时PMD会初始化该结构体用于报告详细的错误信息。

返回值:

- 0 成功, 否则返回负数错误码并设置 ``rte_errno`` 。

刷新(flush)
~~~~~

一个简便的函数用于销毁和一个端口相关的所有流规则。
和连续调用 ``rte_flow_destroy()`` 销毁流规则一样。

.. code-block:: c

   int
   rte_flow_flush(uint8_t port_id,
                  struct rte_flow_error *error);

如果操作失败(概率很小)，流规则仍被视为销毁了并且不再合法，而端口被假设处于不一致的状态中。

参数:

- ``port_id``: 以太网设备端口标识符。
- ``error``: 发生错误时PMD会初始化该结构体用于报告详细的错误信息。

返回值:

- 0 成功, 否则返回负数错误码并设置 ``rte_errno`` 。

查询
~~~~~

查询存在的流规则。

该函数用于获取流规则的指定数据，比如计数器。
数据是由特定动作获取的，这些动作必须在流规则定义时传入。

.. code-block:: c

   int
   rte_flow_query(uint8_t port_id,
                  struct rte_flow *flow,
                  enum rte_flow_action_type action,
                  void *data,
                  struct rte_flow_error *error);

参数:

- ``port_id``: 以太网设备端口标识符。
- ``flow``: 流规则句柄。
- ``action``: 查询的动作类型。
- ``data``: 用于存储查询结果的指针。
- ``error``: 发生错误时PMD会初始化该结构体用于报告详细的错误信息。

返回值:

- 0 成功, 否则返回负数错误码并设置 ``rte_errno`` 。

详细错误报告
-----------------------

*errno* 值对于用户或者应用开发者来说不够精准。有一个专门的错误对象用于提供详细错误信息:

.. code-block:: c

   enum rte_flow_error_type {
       RTE_FLOW_ERROR_TYPE_NONE, /**< No error. */
       RTE_FLOW_ERROR_TYPE_UNSPECIFIED, /**< Cause unspecified. */
       RTE_FLOW_ERROR_TYPE_HANDLE, /**< Flow rule (handle). */
       RTE_FLOW_ERROR_TYPE_ATTR_GROUP, /**< Group field. */
       RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY, /**< Priority field. */
       RTE_FLOW_ERROR_TYPE_ATTR_INGRESS, /**< Ingress field. */
       RTE_FLOW_ERROR_TYPE_ATTR_EGRESS, /**< Egress field. */
       RTE_FLOW_ERROR_TYPE_ATTR, /**< Attributes structure. */
       RTE_FLOW_ERROR_TYPE_ITEM_NUM, /**< Pattern length. */
       RTE_FLOW_ERROR_TYPE_ITEM, /**< Specific pattern item. */
       RTE_FLOW_ERROR_TYPE_ACTION_NUM, /**< Number of actions. */
       RTE_FLOW_ERROR_TYPE_ACTION, /**< Specific action. */
   };

   struct rte_flow_error {
       enum rte_flow_error_type type; /**< Cause field and error types. */
       const void *cause; /**< Object responsible for the error. */
       const char *message; /**< Human-readable error message. */
   };

错误类型 ``RTE_FLOW_ERROR_TYPE_NONE`` 代表没有错误, 这种情况下，其他的字段可以忽略。
其他的错误类型的错误描述为字段 ``cause``。

``cause`` 指针指向引发错误的对象。对于流规则，可能是模式项或者独立的动作。

``message`` 错误描述的字符串。

该对象正常由应用申请，发生错误时有PMD设置。 ``message`` 指针是指向字符串常量的，
应用无需释放，只要相关的DPDK端口保持配置，该指针被视为一直有效。
关闭底层设备或者卸载PMD会导致 ``message`` 指针失效。

注意事项
-------

- DPDK不会自动记录流规则定义或者流规则对象。应用可以记录前者，但必须记录后者。
  PMD为了内部需要也可以这样做，但应用一定不要依赖PMD的记录。

- 流规则不会在端口初始化之间保持。如果应用在退出时没有释放流规则，
  那么在其重启时必须重建流规则。

- API操作是同步阻塞的(不会返回 ``EAGAIN`` )。

- 虽然没有提供可重入/线程安全，但仍应该防止同时在不同设备间的配置操作。
  PMD可能保护其控制路径。

- 管理流规则时不必停止数据路径(TX/RX)。如果无法实现的话，应该返回一个适当的错误码(``EBUSY``)。

- 在停止并重启端口或者执行其他受影响的动作时，是PMD而不是应用负责维护流规则的配置。

设备暴露多个端口，但这些端口共享全局设置，受下面的流规则影响:

- DPDK控制下的所有端口必须行为一致，PMD要确保一个端口的流规则不会受到其他端口的影响。

- 不在DPDK控制下的端口(未受影响的或者由其他应用管理的)，有用于负责管理。
  它们可能影响已存在的流规则并产生未定义的行为。如果PMD感知到这种情况，
  可以阻止流规则的创建。

PMD接口
-------------

PMD的接口定义在 ``rte_flow_driver.h``。其不受API/ABI的版本限制，
因为它并不暴露给应用并且可以独立发展。

当前PMD接口是基于原过滤框架的 *RTE_ETH_FILTER_GENERIC* 过滤类型实现的，
该过滤类型接收单一操作 *RTE_ETH_FILTER_GET* 返回PMD特定的 *rte_flow* 回调(包装在 ``struct rte_flow_ops`` 中)。

这种做法是为了和原过滤框架保持兼容，最终会被替换掉。

- PMD回调准确地实现了 `规则管理`_ 中描述的接口，
  除了已经被转换成指向底层的 ``struct rte_eth_dev`` 指针的端口ID参数。

- 公共API函数在调用PMD函数(无基本的错误检查，无任何校验)前不会处理流规则定义。
  它们仅确保这些回调是非NULL的或者返回 ``ENOSYS`` (不支持的功能)错误。

此外，该接口定义了以下辅助函数:

- ``rte_flow_ops_get()``: 从端口中获取通用流操作结构。

- ``rte_flow_error_set()``: 初始化通用流错误结构。

未来会增加更多。

设备兼容性
--------------------

目前，还没有可以支持所有已描述特性的实现。

因为性能原因，并不期望在PMD中完全以软件模拟方式来实现硬件不支持的特性。
部分支持的特性只要硬件执行大部分工作，剩余部分工作可以交给软件完成。
比如，队列重定向和包识别。

但是，期望PMD可以尽全力满足应用的请求，PMD可以通过各种方法解除硬件限制，
只要不影响到已存在流规则的行为。

以下章节中提供了一些PMD处理兼容性的例子，它们基于旧版本API中的限制。

全局位掩码
~~~~~~~~~~~~~~~~

每个流规则都有自己的每层位掩码，然而硬件对某层可能只支持一种设备相关的位掩码，
因此两个IPv4规则不能使用不同的位掩码。

这种情况下，期望PMD根据第一个创建的流规则的需求自动配置全局位掩码。

后续创建的流规则如果匹配位掩码则可以创建，否则会返回 ``EEXIST`` 错误码。

不支持的(协议)层类型
~~~~~~~~~~~~~~~~~~~~~~~

很多协议可以通过 `数据模式项: RAW`_ 类型模拟。

PMD通过这种方式模拟支持那些报头无法直接被硬件识别的协议。

``ANY`` 模式项
~~~~~~~~~~~~~~~~~~~~

该模式项代表那些硬件很难解析，特别是在更加特殊类型后面的协议。

考虑下面的模式:

.. _table_rte_flow_unsupported_any:

.. table:: L3使用ANY的模式

   +-------+-----------------------+
   | Index | Item                  |
   +=======+=======================+
   | 0     | ETHER                 |
   +-------+-----+---------+-------+
   | 1     | ANY | ``num`` | ``1`` |
   +-------+-----+---------+-------+
   | 2     | TCP                   |
   +-------+-----------------------+
   | 3     | END                   |
   +-------+-----------------------+

要知道TCP是感知不到L3具体协议的，该模式也可以使用下面两个代替:

.. _table_rte_flow_unsupported_any_ipv4:

.. table:: 用IPV4替换ANY

   +-------+--------------------+
   | Index | Item               |
   +=======+====================+
   | 0     | ETHER              |
   +-------+--------------------+
   | 1     | IPV4 (zeroed mask) |
   +-------+--------------------+
   | 2     | TCP                |
   +-------+--------------------+
   | 3     | END                |
   +-------+--------------------+

|

.. _table_rte_flow_unsupported_any_ipv6:

.. table:: 用IPV6替换ANY

   +-------+--------------------+
   | Index | Item               |
   +=======+====================+
   | 0     | ETHER              |
   +-------+--------------------+
   | 1     | IPV6 (zeroed mask) |
   +-------+--------------------+
   | 2     | TCP                |
   +-------+--------------------+
   | 3     | END                |
   +-------+--------------------+

注意一个ANY规则包括多个协议层，这种做法可能会产生大量隐藏的流规则。
因此建议仅支持最常见的场景(作为L2或L3)。

不支持的动作
~~~~~~~~~~~~~~~~~~~

- 包计数(`动作: COUNT`_)和标记(`动作: MARK`_ or `动作: FLAG`_) 与 
  `动作: QUEUE`_ 的组合可以通过软件实现，前提是目标队列仅被单一规则使用。

- 指定了 `动作: DUP`_ + `动作: QUEUE`_ 的规则可以转换成两个结合了 
  `动作: QUEUE`_ 和 `动作: PASSTHRU`_ 的规则。

- 当只提供一个单一目标队列时， `动作: RSS`_ 也可以通过 `动作: QUEUE`_ 实现。

流规则优先级
~~~~~~~~~~~~~~~~~~~

我们不能假设流规则能够被硬件按照创建顺序执行的几个原因:

- 流规则内部可能是以树或者哈希表存储而不是列表。

- 在新增流规则前删除过流规则，那么新增的规则可能会被放到表尾或者重用空闲的实体空间。

- 当包匹配多个规则时，可能会发生复制。

对于重叠的规则(特别是为了使用 `动作: PASSTHRU`_)仅保证在使用不同优先级时结果可预测。

优先级不必在硬件中实现，除非有严格的限制(比如，优先级位)。

因此，优先级可以由PMD纯软件实现。

- 对于希望流规则能够按照正确顺序增加的设备，PMD可以销毁规则并在加入高优先级规则后重建销毁的规则。

- 在初始化时可以为后续的高优先级的规则预留位置(通过创建可配置数量的空规则)。

- 为了保存优先级，PMD可以评估规则是否冲突并调整优先级。

未来发展
-----------------

- 设备配置选择功能，可用于强制永久性配置，而不是依靠现有流程规则自动配置。

- 优化带有由PMD生成的动作类型和指定模式项的 *rte_flow* 规则。
  PMD应该给这些类型分配负数，以免和已存在的类型冲突。参加 `负数类型`_

- 增加在 `属性: 流量方向`_ 中描述的特定出口模式项和动作。

- 在PMD无法处理请求的流规则时可以可选的回退该操作，无需应用处理。

API 迁移
-------------

完整的弃用过滤器类型(通常前缀为 *RTE_ETH_FILTER_*)列表在 ``rte_eth_ctrl.h`` 中，
其中还有转换成 *rte_flow* 规则的方法。

``MACVLAN`` to ``ETH`` → ``VF``, ``PF``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*MACVLAN* 可以转换成以 `动作: VF`_ 或 `动作: PF`_ 终止的 `数据模式项: ETH`_ 流规则

.. _table_rte_flow_migration_macvlan:

.. table:: MACVLAN 转换

   +--------------------------+---------+
   | Pattern                  | Actions |
   +===+=====+==========+=====+=========+
   | 0 | ETH | ``spec`` | any | VF,     |
   |   |     +----------+-----+ PF      |
   |   |     | ``last`` | N/A |         |
   |   |     +----------+-----+         |
   |   |     | ``mask`` | any |         |
   +---+-----+----------+-----+---------+
   | 1 | END                  | END     |
   +---+----------------------+---------+

``ETHERTYPE`` to ``ETH`` → ``QUEUE``, ``DROP``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*ETHERTYPE* 基本上就是以 `动作: QUEUE`_ or `动作: DROP`_ 终止的 `数据模式项: ETH`_ 流规则。

.. _table_rte_flow_migration_ethertype:

.. table:: ETHERTYPE 转换

   +--------------------------+---------+
   | Pattern                  | Actions |
   +===+=====+==========+=====+=========+
   | 0 | ETH | ``spec`` | any | QUEUE,  |
   |   |     +----------+-----+ DROP    |
   |   |     | ``last`` | N/A |         |
   |   |     +----------+-----+         |
   |   |     | ``mask`` | any |         |
   +---+-----+----------+-----+---------+
   | 1 | END                  | END     |
   +---+----------------------+---------+

``FLEXIBLE`` to ``RAW`` → ``QUEUE``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*FLEXIBLE* 可以转换成以 `动作: QUEUE`_ 终止并带有优先级的 `数据模式项: RAW`_ 模式。

.. _table_rte_flow_migration_flexible:

.. table:: FLEXIBLE 转换

   +--------------------------+---------+
   | Pattern                  | Actions |
   +===+=====+==========+=====+=========+
   | 0 | RAW | ``spec`` | any | QUEUE   |
   |   |     +----------+-----+         |
   |   |     | ``last`` | N/A |         |
   |   |     +----------+-----+         |
   |   |     | ``mask`` | any |         |
   +---+-----+----------+-----+---------+
   | 1 | END                  | END     |
   +---+----------------------+---------+

``SYN`` to ``TCP`` → ``QUEUE``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*SYN* 是仅带有启用 ``syn`` 位并且以 `动作: QUEUE`_ 终止的 `数据模式项: TCP`_ 规则。

可以设置优先级来模拟高优先级位。

.. _table_rte_flow_migration_syn:

.. table:: SYN 转换

   +-----------------------------------+---------+
   | Pattern                           | Actions |
   +===+======+==========+=============+=========+
   | 0 | ETH  | ``spec`` | unset       | QUEUE   |
   |   |      +----------+-------------+         |
   |   |      | ``last`` | unset       |         |
   |   |      +----------+-------------+         |
   |   |      | ``mask`` | unset       |         |
   +---+------+----------+-------------+---------+
   | 1 | IPV4 | ``spec`` | unset       | END     |
   |   |      +----------+-------------+         |
   |   |      | ``mask`` | unset       |         |
   |   |      +----------+-------------+         |
   |   |      | ``mask`` | unset       |         |
   +---+------+----------+---------+---+         |
   | 2 | TCP  | ``spec`` | ``syn`` | 1 |         |
   |   |      +----------+---------+---+         |
   |   |      | ``mask`` | ``syn`` | 1 |         |
   +---+------+----------+---------+---+         |
   | 3 | END                           |         |
   +---+-------------------------------+---------+

``NTUPLE`` to ``IPV4``, ``TCP``, ``UDP`` → ``QUEUE``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*NTUPLE* 和指定空L3，`数据模式项: IPV4`_ 作为L3， `数据模式项: TCP`_ 或 `数据模式项: UDP`_ 作为L4并且以 `动作: QUEUE`_ 终止的规则类似。

同样也可以指定优先级。

.. _table_rte_flow_migration_ntuple:

.. table:: NTUPLE 转换

   +-----------------------------+---------+
   | Pattern                     | Actions |
   +===+======+==========+=======+=========+
   | 0 | ETH  | ``spec`` | unset | QUEUE   |
   |   |      +----------+-------+         |
   |   |      | ``last`` | unset |         |
   |   |      +----------+-------+         |
   |   |      | ``mask`` | unset |         |
   +---+------+----------+-------+---------+
   | 1 | IPV4 | ``spec`` | any   | END     |
   |   |      +----------+-------+         |
   |   |      | ``last`` | unset |         |
   |   |      +----------+-------+         |
   |   |      | ``mask`` | any   |         |
   +---+------+----------+-------+         |
   | 2 | TCP, | ``spec`` | any   |         |
   |   | UDP  +----------+-------+         |
   |   |      | ``last`` | unset |         |
   |   |      +----------+-------+         |
   |   |      | ``mask`` | any   |         |
   +---+------+----------+-------+         |
   | 3 | END                     |         |
   +---+-------------------------+---------+

``TUNNEL`` to ``ETH``, ``IPV4``, ``IPV6``, ``VXLAN`` (or other) → ``QUEUE``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*TUNNEL* 匹配通用的 IPv4 和 IPv6 L3/L4-based 隧道类型。

下表中, `数据模式项: ANY`_ 用于覆盖可选的L4。

.. _table_rte_flow_migration_tunnel:

.. table:: TUNNEL 转换

   +-------------------------------------------------------+---------+
   | Pattern                                               | Actions |
   +===+==========================+==========+=============+=========+
   | 0 | ETH                      | ``spec`` | any         | QUEUE   |
   |   |                          +----------+-------------+         |
   |   |                          | ``last`` | unset       |         |
   |   |                          +----------+-------------+         |
   |   |                          | ``mask`` | any         |         |
   +---+--------------------------+----------+-------------+---------+
   | 1 | IPV4, IPV6               | ``spec`` | any         | END     |
   |   |                          +----------+-------------+         |
   |   |                          | ``last`` | unset       |         |
   |   |                          +----------+-------------+         |
   |   |                          | ``mask`` | any         |         |
   +---+--------------------------+----------+-------------+         |
   | 2 | ANY                      | ``spec`` | any         |         |
   |   |                          +----------+-------------+         |
   |   |                          | ``last`` | unset       |         |
   |   |                          +----------+---------+---+         |
   |   |                          | ``mask`` | ``num`` | 0 |         |
   +---+--------------------------+----------+---------+---+         |
   | 3 | VXLAN, GENEVE, TEREDO,   | ``spec`` | any         |         |
   |   | NVGRE, GRE, ...          +----------+-------------+         |
   |   |                          | ``last`` | unset       |         |
   |   |                          +----------+-------------+         |
   |   |                          | ``mask`` | any         |         |
   +---+--------------------------+----------+-------------+         |
   | 4 | END                                               |         |
   +---+---------------------------------------------------+---------+

``FDIR`` to most item types → ``QUEUE``, ``DROP``, ``PASSTHRU``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*FDIR* 要比其他类型复杂，有多种方法模拟它的功能。大部分方法总结于下面。

一些有意不支持的特性:

- 对整个设备配置匹配输入集和掩码的能力，PMD应该根据请求的流规则自动完成。

  如，设备对每个协议类型仅支持一个位掩码，源/地址IPv4位掩码在第一个创建的规则时就永久的设置了。
  之后的IPv4或TCPv4规则仅在和第一个规则兼容时才能创建成功。

  注意，仅应用在已存在流规则上的协议位掩码是永久不变的，其他的仍可以改变。
  在流规则销毁时，相关的协议位掩码恢复可变状态。

- 使用弹性字节过滤时返回四或八字节的匹配数据。虽然可以通过指定动作实现，
  但它会和超过32位(设备支持的话)标签冲突。

- 整个设备RSS处理的副作用。和当前设备配置冲突的流规则不该存在。
  类似的，当设备配置影响到已存在的流规则时也不该被允许。

- 设备操作模式。不支持"none"，因为只要流规则存在过滤就不能禁用。

- 应该根据创建的流规则自动配置"MAC VLAN" 或 "隧道"的完美匹配模式。
- 签名模式的操作未定义，但如果需要，可以通过特定的模式项类型实现。

.. _table_rte_flow_migration_fdir:

.. table:: FDIR 转换

   +----------------------------------------+-----------------------+
   | Pattern                                | Actions               |
   +===+===================+==========+=====+=======================+
   | 0 | ETH, RAW          | ``spec`` | any | QUEUE, DROP, PASSTHRU |
   |   |                   +----------+-----+                       |
   |   |                   | ``last`` | N/A |                       |
   |   |                   +----------+-----+                       |
   |   |                   | ``mask`` | any |                       |
   +---+-------------------+----------+-----+-----------------------+
   | 1 | IPV4, IPv6        | ``spec`` | any | MARK                  |
   |   |                   +----------+-----+                       |
   |   |                   | ``last`` | N/A |                       |
   |   |                   +----------+-----+                       |
   |   |                   | ``mask`` | any |                       |
   +---+-------------------+----------+-----+-----------------------+
   | 2 | TCP, UDP, SCTP    | ``spec`` | any | END                   |
   |   |                   +----------+-----+                       |
   |   |                   | ``last`` | N/A |                       |
   |   |                   +----------+-----+                       |
   |   |                   | ``mask`` | any |                       |
   +---+-------------------+----------+-----+                       |
   | 3 | VF, PF (optional) | ``spec`` | any |                       |
   |   |                   +----------+-----+                       |
   |   |                   | ``last`` | N/A |                       |
   |   |                   +----------+-----+                       |
   |   |                   | ``mask`` | any |                       |
   +---+-------------------+----------+-----+                       |
   | 4 | END                                |                       |
   +---+------------------------------------+-----------------------+

``HASH``
~~~~~~~~

没有和该过滤器类型对应的模式项，因为它转换为全局设备设置而不是模式项。
设备的配置可以根据创建的流规则自动设置。

``L2_TUNNEL`` to ``VOID`` → ``VXLAN`` (或其他)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

所有数据包都匹配。该类型修改输入包，把它们封装到选定的隧道类型中，也可以把它们重定向到VF。

标签(基于转发)的目的池可以通过使用了 `动作: DUP`_ 的其他流规则模拟。

.. _table_rte_flow_migration_l2tunnel:

.. table:: L2_TUNNEL 转发

   +---------------------------+--------------------+
   | Pattern                   | Actions            |
   +===+======+==========+=====+====================+
   | 0 | VOID | ``spec`` | N/A | VXLAN, GENEVE, ... |
   |   |      |          |     |                    |
   |   |      |          |     |                    |
   |   |      +----------+-----+                    |
   |   |      | ``last`` | N/A |                    |
   |   |      +----------+-----+                    |
   |   |      | ``mask`` | N/A |                    |
   |   |      |          |     |                    |
   +---+------+----------+-----+--------------------+
   | 1 | END                   | VF (optional)      |
   +---+                       +--------------------+
   | 2 |                       | END                |
   +---+-----------------------+--------------------+
